{"version":3,"sources":["../../src/rules/newlineAfterDescription.js"],"names":["jsdoc","report","context","jsdocNode","sourceCode","indent","always","description","trim","tags","length","_","has","options","descriptionEndsWithANewline","endsWith","sourceLines","getText","split","lastDescriptionLine","findLastIndex","line","replace","last","fixer","injectedLine","splice","replaceText","join","iterateAllJsdocs","meta","fixable","schema","enum","type","noTrim"],"mappings":"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","sourcesContent":["import _ from 'lodash';\nimport iterateJsdoc from '../iterateJsdoc';\n\nexport default iterateJsdoc(({\n  jsdoc,\n  report,\n  context,\n  jsdocNode,\n  sourceCode,\n  indent,\n}) => {\n  let always;\n\n  if (!jsdoc.description.trim() || !jsdoc.tags.length) {\n    return;\n  }\n\n  if (_.has(context.options, 0)) {\n    always = context.options[0] === 'always';\n  } else {\n    always = true;\n  }\n\n  const descriptionEndsWithANewline = jsdoc.description.endsWith('\\n');\n\n  if (always) {\n    if (!descriptionEndsWithANewline) {\n      const sourceLines = sourceCode.getText(jsdocNode).split('\\n');\n      const lastDescriptionLine = _.findLastIndex(sourceLines, (line) => {\n        return line.replace(/^\\s*\\*\\s*/u, '') === _.last(jsdoc.description.split('\\n'));\n      });\n      report('There must be a newline after the description of the JSDoc block.', (fixer) => {\n        // Add the new line\n        const injectedLine = `${indent} *` +\n          (sourceLines[lastDescriptionLine].endsWith('\\r') ? '\\r' : '');\n        sourceLines.splice(lastDescriptionLine + 1, 0, injectedLine);\n\n        return fixer.replaceText(jsdocNode, sourceLines.join('\\n'));\n      }, {\n        line: lastDescriptionLine,\n      });\n    }\n  } else if (descriptionEndsWithANewline) {\n    const sourceLines = sourceCode.getText(jsdocNode).split('\\n');\n    const lastDescriptionLine = _.findLastIndex(sourceLines, (line) => {\n      return line.replace(/^\\s*\\*\\s*/u, '') === _.last(jsdoc.description.split('\\n'));\n    });\n    report('There must be no newline after the description of the JSDoc block.', (fixer) => {\n      // Remove the extra line\n      sourceLines.splice(lastDescriptionLine, 1);\n\n      return fixer.replaceText(jsdocNode, sourceLines.join('\\n'));\n    }, {\n      line: lastDescriptionLine,\n    });\n  }\n}, {\n  iterateAllJsdocs: true,\n  meta: {\n    fixable: 'whitespace',\n    schema: [\n      {\n        enum: ['always', 'never'],\n        type: 'string',\n      },\n    ],\n    type: 'layout',\n  },\n  noTrim: true,\n});\n"],"file":"newlineAfterDescription.js"}